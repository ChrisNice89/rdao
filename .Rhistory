cloneable    = FALSE,
private = list(.validator = NULL,
.dbpassword = ""),
public = list(
builderProvider = "",
driver = "",
path = "",
dsn = "",
database = "",
server = "",
host = "",
port = 0,
credentials = NULL,
initialize = function(provider) {
private$.validator <- Validator$new(self)
self$builderProvider <- provider
private$.validator$makeReadonly("builderProvider")
invisible(self$print())
},
addCredentials = function(username = "",
password = "") {
private$.validator$makeReadwrite("credentials")
self$credentials <-Credentials$new(username = username, password = password)
private$.validator$makeReadonly("credentials")
invisible(self)
},
#actual implementation
build = function() {
prc <- "build()"
if (!private$.validator$isNullString(self$path)) {
if (!file.exists(self$path)) {
msg <- paste("Ungültiger Pfad", self$path)
private$.validator$throwError(msg, prc)
}
}
switch(
self$builderProvider,
msAccess = {
dbq <- paste0("DBQ=", self$path)
driver <-
"Driver={Microsoft Access Driver (*.mdb, *.accdb)};"
dbiDriver <- odbc::odbc
connectionstring <- paste0(driver, dbq)
return (msAccessConnection$new(provider = self$builderProvider,dbiDriver,connectionstring))
},
dbFile = {
dbiDriver <- RSQLite::SQLite
return (dbFileConnection$new(provider = self$builderProvider, dbiDriver,self$path))
},
dataFrame = {
dbiDriver <- RSQLite::SQLite
return (sqliteConnection$new(provider = self$builderProvider, ":memory:",dbiDriver))
},
mySql = {
msg <- paste("Noch nicht implementiert:", self$builderProvider)
private$.validator$throwError(msg, prc)
},
msSql = {
msg <- paste("Noch nicht implementiert:", self$builderProvider)
private$.validator$throwError(msg, prc)
},
{
msg <-
msg <- paste("Noch nicht implementiert:", self$builderProvider)
private$.validator$throwError(msg, prc)
}
)
},
print = function() {
msg <- paste("<", class(self)[1], ">", sep = "")
if (private$.validator$isCharacter(self$builderProvider) ) {
msg <-
paste(msg, " for provider: <", self$builderProvider, ">", sep = "")
}
cat(msg, " created", "\n", sep = "")
invisible(self)
}
)
)
#' Abstrakte sqlConnection (wrapper um DBI)
#'
#'
#' @docType class
#' @importFrom R6 R6Class
#' @keywords data
#' @family sql
#'
#' @section Construction:
#' ```
#' xxxxxxxxxxxxxxxxxxxxxx
#' ```
#'
#' @return Object of \code{\link{R6Class}} xxxxxxxxxxxxxxxxxxxx (x)
#' @format \code{\link{R6Class}} object.
#' @examples
#' xxxxxxxxxxxxxxxxxxxxxx
#'
#'
#' @field x blabla.
#' @field y blabla.
#'
#' @section Methods:
#' \describe{
#'   \item{Documentation}{For full documentation of each method go to https://github.com/ChrisNice89/rdao}
#'   \item{\code{new()}}{xxx \code{Factory}.}
#'   \item{\code{xx(yy,yy="")}}{xx \code{zz}.}
#'   \item{\code{zz(yy,yy="")}}{xx \code{zz}.}}
#'
#' @include sqlInterface.R
#' @include utils.R
#' @include sqlCommand.R
sqlConnection <- R6::R6Class(
classname = "Abstrakt SqlConnection",
inherit = sqlInterface,
portable = TRUE,
private = list(
.validator = NULL,
.connection = NULL,
.driver = NULL,
.credentials = list(),
.dbiConnect = function(driverGenerator, ...) {
if (is.function(driverGenerator)) {
DBI::dbConnect(driverGenerator(), ...)
} else {
private$.validator$throwError("Driver generator ist ungültig", "connect()")
}
},
validator = function() {
return(private$.validator)
}
),
public = list(
provider = "",
initialize = function(..., provider) {
private$.validator <- Validator$new(self)
private$.credentials$params <- list(...)
self$provider <- provider
private$.validator$makeReadonly("provider")
invisible(self$print())
},
createQuery = function(sql) {
return(sqlQuery$new(connection =  self,
sql = sql))
},
execute = function(query, disconnectAfter = TRUE) {
prc <- "execute()"
if (inherits(query, "SqlCommand")) {
switch(query$type,
"fetch" = {
if (self$connect()) {
dbi.result <- DBI::dbGetQuery(conn = private$.connection,
statement = query$sql)
}
},
"exec" = {
if (self$connect()) {
dbi.result <-
DBI::dbExecute(conn = private$.connection,
statement = query$sql)
}
},
{
msg <-
paste("Commantype: <",
query$type,
"> nicht implementiert",
sep = "")
private$.validator$throwError(msg, prc)
})
} else {
private$.validator$throwError("Command ist vom falschen Datentyp", prc)
}
if (disconnectAfter) {
on.exit(self$disconnect())
}
if (is.data.frame(dbi.result)) {
result<-super$sqlResult(connection =self ,data = dbi.result)
}
query$print("ausgeführt")
return(result)
},
connect = function() {
if (!self$isConnected()) {
private$.connection <-
do.call(private$.dbiConnect, private$.credentials$params)
}
return(self$isConnected())
},
disconnect = function() {
if (self$isConnected()) {
DBI::dbDisconnect(private$.connection)
msg <- paste("<", class(self)[1], ">", sep = "")
if (!private$.validator$isNullString(self$provider)) {
msg <-
paste(msg, "> for provider: <", self$provider, ">", sep = "")
}
message(msg, " Disconnect")
}
return(!self$isConnected())
},
finalize = function() {
self$disconnect()
},
isConnected = function() {
if (!is.null(private$.connection)) {
return(DBI::dbIsValid(private$.connection))
} else {
return(FALSE)
}
},
getTables = function() {
return(dbListTables(private$.connection))
},
print = function() {
msg <- paste("<", class(self)[1], ">", sep = "")
if (!private$.validator$isNullString(self$provider)) {
msg <-
paste(msg, "> for provider: <", self$provider, ">", sep = "")
}
cat(msg, " created", "\n", sep = "")
invisible(self)
}
)
)
# Konkrete interface Klassen ("Provider")
# Konstruktoren bieten schwache Typsicherheit für die aufrufende Klasse.
# Ermöglichen das bauen von Verbindungen (DBI) die heterogene Parameter (je nach Datenprovider) benötigen
dbFileConnection <- R6::R6Class(
classname = "SqlConnection",
inherit = sqlConnection,
portable = TRUE,
public = list(
initialize = function(driverGenerator, path, provider = provider) {
super$initialize(driverGenerator, path, provider = provider)
invisible(self)
}
)
)
msAccessFileConnection <- R6::R6Class(
classname = "SqlConnection",
inherit = sqlConnection,
portable = TRUE,
public = list(
initialize = function(provider = provider,
driverGenerator,
connectionstring) {
super$initialize(driverGenerator, connectionstring, provider = provider)
invisible(self)
}
)
)
#' Aktuell wrapper um ein Dataframe aus einer Sql Abfrage
#' Könnte in der Zukunft um CRUD-Funktionalitäten erweitert werden.
#' Dataframe sollte komplett gekapselt werden um zb "AddColumn" zu verhindern.
#'
#'
#' @docType class
#' @importFrom R6 R6Class
#' @keywords data
#' @family sql
#'
#' @section Construction:
#' ```
#' xxxxxxxxxxxxxxxxxxxxxx
#' ```
#'
#' @return Object of \code{\link{R6Class}} xxxxxxxxxxxxxxxxxxxx (x)
#' @format \code{\link{R6Class}} object.
#' @examples
#' xxxxxxxxxxxxxxxxxxxxxx
#'
#'
#' @field x blabla.
#' @field y blabla.
#'
#' @section Methods:
#' \describe{
#'   \item{Documentation}{For full documentation of each method go to https://github.com/ChrisNice89/rdao}
#'   \item{\code{new()}}{xxx \code{Factory}.}
#'   \item{\code{xx(yy,yy="")}}{xx \code{zz}.}
#'   \item{\code{zz(yy,yy="")}}{xx \code{zz}.}}
#'
#' @include utils.R
#' @include sqlInterface.R
sqlResult<- R6::R6Class(
classname = "SqlResult",
inherit = generics,
portable = TRUE,
private = list(
.validator = NULL,
.connection=NULL,
.eod=FALSE,
.shared=NULL
),
public = list(
initialize = function(connection, data) {
private$.validator <- Validator$new(self)
if (private$.validator$isTrustedConnection(connection)) {
if (is.data.frame(data)) {
super$initialize(data)
private$.shared<-super$getPointer()
private$.connection <- connection
}else {
private$.validator$throwWarning("Kein Dataframe","initialize()")
}
}else{
private$.validator$throwError("Keine gültige Verbindung","initialize()")
}
},
getRecords=function(){
i<-private$.shared$index
return(private$.shared$df[i,])
},
countRows=function(){
return(nrow(private$.shared$df))
},
countColumns=function(){
return(ncol(private$.shared$df))
},
read=function(){
i<-private$.shared$index
on.exit(self$row(i+1))
return(!private$.eod)
},
row=function(i){
if(i>self$countRows()){
private$.eod<-TRUE
private$.shared$index<-1
}else{
private$.eod<-FALSE
private$.shared$index<-i
}
invisible(self)
},
toMatrix=function(){
functor <- function(obj) {
structure(
function(i,j) {
obj$matrixAccess(i,j)
},
class = "functor",
obj = obj
)
}
return(functor(super))
},
update=function(){
},
delete=function(rows){
private$.shared$df <- super$getPointer()$df[-rows, ]
invisible(self)
},
add=function(){
}
)
)
`[[.functor` <- `$.functor`
`[[<-.functor` <- `$<-.functor`
`$.functor` <- function(x, name) {
attr(x, "obj", exact = TRUE)[[name]]
}
`$<-.functor` <- function(x, name, value) {
obj <- attr(x, "obj", exact = TRUE)
obj[[name]] <- value
x
}
`[[.functor` <- `$.functor`
`[[<-.functor` <- `$<-.functor`
#' Abstrakte Klasse implementiert Interface
#'
#'
#' @docType class
#' @importFrom R6 R6Class
#' @keywords data
#' @family sql
#'
#' @section Construction:
#' ```
#' xxxxxxxxxxxxxxxxxxxxxx
#' ```
#'
#' @return Object of \code{\link{R6Class}} xxxxxxxxxxxxxxxxxxxx (x)
#' @format \code{\link{R6Class}} object.
#' @examples
#' xxxxxxxxxxxxxxxxxxxxxx
#'
#'
#' @field x blabla.
#' @field y blabla.
#'
#' @section Methods:
#' \describe{
#'   \item{Documentation}{For full documentation of each method go to https://github.com/ChrisNice89/rdao}
#'   \item{\code{new()}}{xxx \code{Factory}.}
#'   \item{\code{xx(yy,yy="")}}{xx \code{zz}.}
#'   \item{\code{zz(yy,yy="")}}{xx \code{zz}.}}
#'
#' @include utils.R
#' @include sqlResult.R
sqlInterface <- R6::R6Class(
classname = "Abstarkt SqlResult Interface",
inherit = NULL,
portable = TRUE,
public = list(
initialize = function() {
}
),
private = list(
remove = function(class, fields) {
class$private_fields <- NULL
class$private_methods <- NULL
for (c in tools::toTitleCase(fields)) {
mthd_name <- c
mthd_set <-
glue::glue("class$public_methods$set{mthd_name}<-NULL")
mthd_get <-
glue::glue("class$public_methods$get{mthd_name}<-NULL")
eval(parse(text = mthd_get))
eval(parse(text = mthd_set))
}
},
sqlResult = function(connection, dataframe) {
if (!private$.validator$isTrustedConnection(connection)) {
if (!is.data.frame(dataframe)) {
}
}
obj <- generics
fields <- colnames(dataframe)
obj$set("private", "getPointer", function()
private$e, overwrite = TRUE)
obj$set("private", "e", new.env(), overwrite = TRUE)
obj$set("private", "matrixAccess", function(i, j) {
private$e$index <- i
private$e$df[i, j]
}
, overwrite = TRUE)
obj$set("public", "initialize", function(df) {
private$e$df <- df
private$e$index <- 1
invisible(self)
}, overwrite = TRUE)
# vGetterSetter<-Vectorize(private$implementGetterSetter,vectorize.args =c("class","name"))
# vGetterSetter(obj,fields)
for (f in fields) {
mthd_name <- f
mthd_set <-
glue::glue("function(value) private$e$df[private$e$index,]${mthd_name} <-value")
mthd_get <-
glue::glue("function() private$e$df[private$e$index,]${mthd_name}")
mthd_name <- tools::toTitleCase(f)
obj$set("public",
paste("get", mthd_name, sep = ""),
eval(parse(text = mthd_get)),
overwrite = TRUE)
obj$set("public",
paste("set", mthd_name, sep = ""),
eval(parse(text = mthd_set)),
overwrite = TRUE)
}
on.exit(private$remove(obj, fields))
return(sqlResult$new(connection , dataframe))
}
)
)
generics <- R6::R6Class(
classname = "Generics",
inherit = NULL,
portable = TRUE,
private = list(),
public = list(
initialize = function() {
}
)
)
`[[.functor` <- `$.functor`
`[[<-.functor` <- `$<-.functor`
`$.functor` <- function(x, name) {
attr(x, "obj", exact = TRUE)[[name]]
}
`$<-.functor` <- function(x, name, value) {
obj <- attr(x, "obj", exact = TRUE)
obj[[name]] <- value
x
}
`[[.functor` <- `$.functor`
`[[<-.functor` <- `$<-.functor`
#library(rdao)
f<-connectionFactory()
b<-f$dbFile("/Users/cnitz/Dev/R/rdao/db files external/Diamonds.db")
cnn<-b$build()
result<-cnn$createQuery(sql = "Select carat,color FROM diamonds LIMIT 10")$fetch()
result$countRows()
m<-result$toMatrix()
m(1)
m(1)
d$carat<-1
d<-m(1)
d$carat<-1
d$carat
installer <- function(pkg){
new.pkg <- pkg[!(pkg %in% installed.packages()[, "Package"])]
if (length(new.pkg))
install.packages(new.pkg, dependencies = TRUE)
sapply(pkg, require, character.only = TRUE)
}
packages<- c("devtools", "roxygen2","R6","rmarkdown","pryr","DBI")
installer(packages)
library(roxygen2)
setwd("~/Dev/R/rdao")
document()
devtools::install_github("Chrisnice89/rdao")
library(rdao)
