\documentclass[]{article}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\usepackage{fixltx2e} % provides \textsubscript
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
\else % if luatex or xelatex
  \ifxetex
    \usepackage{mathspec}
  \else
    \usepackage{fontspec}
  \fi
  \defaultfontfeatures{Ligatures=TeX,Scale=MatchLowercase}
\fi
% use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
% use microtype if available
\IfFileExists{microtype.sty}{%
\usepackage{microtype}
\UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\usepackage[margin=1in]{geometry}
\usepackage{hyperref}
\hypersetup{unicode=true,
            pdftitle={Framework},
            pdfborder={0 0 0},
            breaklinks=true}
\urlstyle{same}  % don't use monospace font for urls
\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\usepackage{framed}
\definecolor{shadecolor}{RGB}{248,248,248}
\newenvironment{Shaded}{\begin{snugshade}}{\end{snugshade}}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{0.94,0.16,0.16}{#1}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.77,0.63,0.00}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\BuiltInTok}[1]{#1}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textit{#1}}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{#1}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{0.64,0.00,0.00}{\textbf{#1}}}
\newcommand{\ExtensionTok}[1]{#1}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\ImportTok}[1]{#1}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{#1}}}
\newcommand{\NormalTok}[1]{#1}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.81,0.36,0.00}{\textbf{#1}}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textit{#1}}}
\newcommand{\RegionMarkerTok}[1]{#1}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\usepackage{graphicx,grffile}
\makeatletter
\def\maxwidth{\ifdim\Gin@nat@width>\linewidth\linewidth\else\Gin@nat@width\fi}
\def\maxheight{\ifdim\Gin@nat@height>\textheight\textheight\else\Gin@nat@height\fi}
\makeatother
% Scale images if necessary, so that they will not overflow the page
% margins by default, and it is still possible to overwrite the defaults
% using explicit options in \includegraphics[width, height, ...]{}
\setkeys{Gin}{width=\maxwidth,height=\maxheight,keepaspectratio}
\IfFileExists{parskip.sty}{%
\usepackage{parskip}
}{% else
\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}
}
\setlength{\emergencystretch}{3em}  % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{0}
% Redefines (sub)paragraphs to behave more like sections
\ifx\paragraph\undefined\else
\let\oldparagraph\paragraph
\renewcommand{\paragraph}[1]{\oldparagraph{#1}\mbox{}}
\fi
\ifx\subparagraph\undefined\else
\let\oldsubparagraph\subparagraph
\renewcommand{\subparagraph}[1]{\oldsubparagraph{#1}\mbox{}}
\fi

%%% Use protect on footnotes to avoid problems with footnotes in titles
\let\rmarkdownfootnote\footnote%
\def\footnote{\protect\rmarkdownfootnote}

%%% Change title format to be more compact
\usepackage{titling}

% Create subtitle command for use in maketitle
\providecommand{\subtitle}[1]{
  \posttitle{
    \begin{center}\large#1\end{center}
    }
}

\setlength{\droptitle}{-2em}

  \title{Framework}
    \pretitle{\vspace{\droptitle}\centering\huge}
  \posttitle{\par}
    \author{}
    \preauthor{}\postauthor{}
    \date{}
    \predate{}\postdate{}
  

\begin{document}
\maketitle

\hypertarget{vorwort}{%
\subsection{Vorwort}\label{vorwort}}

Da ich am 01.10 eine neue Stelle als Java Entwickler bei einer Bank
angetreten habe und mich beruflich mit Datenbank Anwendungen und ORM
(englisch object-relational mapping) beschäftige, habe ich das Projekt
genutzt, um mich dieser Thematik in R anzunehmen. Neben der reinen
(Objektorientierten) Programmierung stand dabei die Softwarepaketierung
im Fokus. Dafür habe ich das Projekt als eigenständiges Paket umgesetzt
und für die weitere Distribution auf Github hochgeladen.

Die kommentierung von Code habe ich aus Übersichtsgründen weggelassen
und dafür mehr Aufwand in die Benennung von (sprechenden) Variablen und
grundlegender Paketarchitektur aufgebracht. Des Weiteren kann mit
?rdao::DieKlasse die Hilfe aufgerufen werden. Zeitlich war es mir leider
nicht möglich, die Hilfe der einzelnen Klassen inhaltlich zu füllen.

Aus technischen Gründen musste ich während der Entwicklung von einer
Access Datenbank abweichen. Alternativ habe ich daher aus dem Diamond
Datensatz eine .db Datei erstellt und diese unter ``rdao/db files
external/Diamonds.db'' auf Github abgelegt. Der originale Datensatz kann
dem Paket nach dem Laden mit rdao::diamonds (siehe ?rdao::diamonds)
entnommen werden.

\hypertarget{installation}{%
\subsection{Installation}\label{installation}}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# helper}
\NormalTok{installer <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(pkg)\{}
\NormalTok{  new.pkg <-}\StringTok{ }\NormalTok{pkg[}\OperatorTok{!}\NormalTok{(pkg }\OperatorTok{%in%}\StringTok{ }\KeywordTok{installed.packages}\NormalTok{()[, }\StringTok{"Package"}\NormalTok{])]}
  \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{length}\NormalTok{(new.pkg))}
    \KeywordTok{install.packages}\NormalTok{(new.pkg, }\DataTypeTok{dependencies =} \OtherTok{TRUE}\NormalTok{)}
  \KeywordTok{sapply}\NormalTok{(pkg, require, }\DataTypeTok{character.only =} \OtherTok{TRUE}\NormalTok{)}
\NormalTok{\}}
\NormalTok{packages<-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"devtools"}\NormalTok{,}\StringTok{"R6"}\NormalTok{,}\StringTok{"DBI"}\NormalTok{)}
\KeywordTok{installer}\NormalTok{(packages)}
\CommentTok{#> Loading required package: devtools}
\CommentTok{#> Loading required package: usethis}
\CommentTok{#> Loading required package: R6}
\CommentTok{#> Loading required package: DBI}
\CommentTok{#> devtools       R6      DBI }
\CommentTok{#>     TRUE     TRUE     TRUE}
\NormalTok{devtools}\OperatorTok{::}\KeywordTok{install_github}\NormalTok{(}\StringTok{"Chrisnice89/rdao"}\NormalTok{)}
\CommentTok{#> Skipping install of 'rdao' from a github remote, the SHA1 (d176efc3) has not changed since last install.}
\CommentTok{#>   Use `force = TRUE` to force installation}
\end{Highlighting}
\end{Shaded}

\hypertarget{basics}{%
\subsection{Basics}\label{basics}}

Laden des Pakets

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(rdao)}
\CommentTok{#> This package ist created,developed and copyrighted by Christoph Nitz.}
\CommentTok{#> Interested parties may contact <Christoph.Nitz89@gmail.com>}
\end{Highlighting}
\end{Shaded}

Für den Testlauf des Paketes den Pfad zur db (Gitub-Ordner: ``db files
external/Diamonds.db'') in einer Variablen ablegen:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{path<-}\StringTok{"/Users/cnitz/Dev/R/rdao/db files external/Diamonds.db"}
\end{Highlighting}
\end{Shaded}

Um eine Klasse aus dem Paket verwenden zu können, muss eine `factory()'
Funktion aufgerufen werden. Unter einer Klasse (auch Objekttyp genannt)
versteht man in der objektorientierten Programmierung ein abstraktes
Modell bzw. einen Bauplan für eine Reihe von ähnlichen Objekten:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f <-}\StringTok{ }\KeywordTok{connectionFactory}\NormalTok{()}
\CommentTok{#> <Validator> for parent class: <SqlFactory> created}
\CommentTok{#> <SqlFactory> created}
\KeywordTok{class}\NormalTok{(f)}
\CommentTok{#> [1] "SqlFactory" "R6"}
\end{Highlighting}
\end{Shaded}

Die \texttt{connectionFactory()} Funktion instanziert intern ein Objekt
der Klasse `SqlFactory'. Sobald die factory geladen wurde, kann diese
jederzeit wieder verwendet werden um ein korrespondierendes Objekt zu
erstellen. Eigenschaften und Methoden der instanzierten Objekte können
mit \texttt{\$} aufgerufen werden:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{#Für ein db File}
\NormalTok{builder.dbFile<-f}\OperatorTok{$}\KeywordTok{dbFile}\NormalTok{(path)}
\CommentTok{#> <Validator> for parent class: <Builder> created}
\CommentTok{#> <Builder> for provider: <dbFile> created}

\KeywordTok{class}\NormalTok{(builder.dbFile)}
\CommentTok{#> [1] "Builder" "R6"}

\CommentTok{#Für eine MS Access Db}
\NormalTok{builder.Access<-f}\OperatorTok{$}\KeywordTok{msAccess}\NormalTok{(}\StringTok{"/file doesnt exisist"}\NormalTok{)}
\CommentTok{#> <Validator> for parent class: <Builder> created}
\CommentTok{#> <Builder> for provider: <msAccess> created}

\CommentTok{#Für MySql / Nicht implementiert}
\NormalTok{builder.mySql<-f}\OperatorTok{$}\KeywordTok{mySql}\NormalTok{(}\DataTypeTok{database =} \StringTok{"test_db"}\NormalTok{,}\DataTypeTok{uid =} \StringTok{"mySql"}\NormalTok{,}\DataTypeTok{pwd =} \StringTok{"password"}\NormalTok{,}\DataTypeTok{host =} \StringTok{"localhost"}\NormalTok{,}\DataTypeTok{port =} \DecValTok{5432}\NormalTok{)}
\CommentTok{#> <Validator> for parent class: <Builder> created}
\CommentTok{#> <Builder> for provider: <mySql> created}
\end{Highlighting}
\end{Shaded}

Methoden und Felder (properties):

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{#Methode ohne Parameterübergabe }
\NormalTok{builder.dbFile}\OperatorTok{$}\KeywordTok{addCredentials}\NormalTok{()}
\CommentTok{#> <Validator> for parent class: <Credentials> created}
\CommentTok{#> <Credentials> for User: <> created}

\CommentTok{#Methode mit Parameterübergabe}
\NormalTok{builder.dbFile}\OperatorTok{$}\KeywordTok{addCredentials}\NormalTok{(}\DataTypeTok{username =} \StringTok{"Admin"}\NormalTok{,}\DataTypeTok{password =} \StringTok{"SesameOpen"}\NormalTok{)}
\CommentTok{#> <Validator> for parent class: <Credentials> created}
\CommentTok{#> <Credentials> for User: <Admin> created}

\CommentTok{#Zugriff auf Felder ohne abschließende '()'}
\NormalTok{builder.dbFile}\OperatorTok{$}\NormalTok{path}
\CommentTok{#> [1] "/Users/cnitz/Dev/R/rdao/db files external/Diamonds.db"}

\CommentTok{#Zuweisung eines Wertes zu einem Feld}
\NormalTok{builder.dbFile}\OperatorTok{$}\NormalTok{path<-}\StringTok{"new path"}
\NormalTok{builder.dbFile}\OperatorTok{$}\NormalTok{path}
\CommentTok{#> [1] "new path"}
\NormalTok{builder.dbFile}\OperatorTok{$}\NormalTok{path<-path}

\CommentTok{#Readonly Feld - Wert des Feldes kann nicht geändert werden #Error!}
\NormalTok{builder.dbFile}\OperatorTok{$}\NormalTok{builderProvider}
\CommentTok{#> [1] "dbFile"}

\CommentTok{#builder.dbFile$builderProvider<-"msAccess"}
\CommentTok{#Fehler in builder.dbFile$builderProvider <- "msAccess" : }
\CommentTok{#kann den Wert einer festgestellten Bindung für 'builderProvider' nicht ändern}
\end{Highlighting}
\end{Shaded}

Methoden Verkettung:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{(builder.dbFile}\OperatorTok{$}\NormalTok{credentials)}
\CommentTok{#> [1] "Credentials" "R6"}
\NormalTok{builder.dbFile}\OperatorTok{$}\NormalTok{credentials}\OperatorTok{$}\NormalTok{username}
\CommentTok{#> [1] "Admin"}
\end{Highlighting}
\end{Shaded}

Unter Method chaining (engl. chaining = Verkettung) wird in der Welt der
objektorientierten Programmierung (OOP) eine spezielle Syntax
verstanden, die das Ausführen einer Reihe von Methoden eines Objektes
beschreibt.

\hypertarget{anwendung}{%
\subsection{Anwendung}\label{anwendung}}

Data Access Object (DAO, englisch für Datenzugriffsobjekt) ist ein
Entwurfsmuster, das den Zugriff auf unterschiedliche Arten von
Datenquellen (z. B. Datenbanken, Dateisystem) so kapselt, dass die
angesprochene Datenquelle ausgetauscht werden kann, ohne dass der
aufrufende Code geändert werden muss. Dadurch soll die eigentliche
Programmlogik von technischen Details der Datenspeicherung befreit
werden und flexibler einsetzbar sein. DAO ist also ein Muster für die
Gestaltung von Programmierschnittstellen (APIs).

Die konkrete Implementierung der Objekte wurde mit Hilfe von R6 Klassen
umgesetzt. Aus programmatischen Gründen wurde dabei gänzlich auf aktive
Bindungen innerhalb der Klassen verzichtet. Des Weiteren wird im Kern
für die Kommunikation zwischen Datenbank(en) und der Anwednung auf das
DBI Interface zurückgegriffen.

\hypertarget{eigenschaften}{%
\subsubsection{Eigenschaften}\label{eigenschaften}}

\begin{itemize}
\tightlist
\item
  DAOs abstrahieren den Zugriff auf Datenbanken nicht vollständig, da
  sie nicht für die Transformation der Daten in die Struktur der
  Datenbank verantwortlich sind.
\item
  DAOs sind jeweils für ein spezielles Speichermedium optimiert. Der
  Zugriff auf dieses Medium wird über das vom DAO vorgegebene bzw. zu
  implementierende API vorgenommen.
\item
  DAOs minimieren den Portierungsaufwand einer Anwendung beim Wechsel
  des Speichermediums.
\end{itemize}

Die Methoden der \texttt{SqlFactory} instanzieren intern ein Objekt vom
Typ `Builder'. Der Erbauer (englisch builder) ist ein Entwurfsmuster
(buildern pattern) aus dem Bereich der Softwareentwicklung. Es gehört
zur Kategorie der Erzeugungsmuster und trennt die Konstruktion komplexer
Objekte von deren Repräsentationen, wodurch dieselben
Konstruktionsprozesse wiederverwendet werden können.

Der Einsatz des Erbauer-Entwurfsmusters bietet sich an, wenn

\textbf{1} Zu einem komplexen Objekt unterschiedliche Repräsentationen
existieren sollen

\textbf{2} Die Konstruktion eines komplexen Objekts unabhängig von der
Erzeugung der Bestandteile sein soll

\textbf{3} Der Konstruktionsablauf einen internen Zustand erfordert, der
vor einem Klienten verborgen werden soll

Erstellen einer Verbindung mit\texttt{builder\$build()}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{connection.dbFile<-builder.dbFile}\OperatorTok{$}\KeywordTok{build}\NormalTok{()}
\CommentTok{#> <Validator> for parent class: <SqlConnection> created}
\CommentTok{#> <SqlConnection>> for provider: <dbFile> created}

\KeywordTok{class}\NormalTok{(connection.dbFile)}
\CommentTok{#> [1] "SqlConnection"          "Abstrakt SqlConnection"}
\CommentTok{#> [3] "R6"}

\CommentTok{#connection.Accees<-builder.Access$build()}
\CommentTok{#Fehler: <Builder>}
\CommentTok{#Proc: <build()>}
\CommentTok{#Beschreibung: <Ungültiger Pfad "/file doesnt exisist"> }

\CommentTok{#connection.dbFile<-builder.mySql$build()}
\CommentTok{#Fehler: <Builder>}
\CommentTok{#Proc: <build()>}
\CommentTok{#Beschreibung: <Noch nicht implementiert: mySql> }
\end{Highlighting}
\end{Shaded}

Der Konstruktionsprozess wird an einer dedizierten Stelle (im
\texttt{Builder}) gesteuert; spätere Änderungen -- etwa ein
Mehrphasen-Konstruktionsprozess statt einer Einphasen-Konstruktion --
lassen sich ohne Änderung der Klienten realisieren. Es besteht eine enge
Kopplung zwischen Produkt, konkretem Erbauer und den am
Konstruktionsprozess beteiligten Klassen (hier die \texttt{SqlFactory}
als Direktor).

\hypertarget{die-verbindung}{%
\subsection{Die Verbindung}\label{die-verbindung}}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{connection.dbFile}\OperatorTok{$}\KeywordTok{isConnected}\NormalTok{()}
\CommentTok{#> [1] FALSE}
\NormalTok{connection.dbFile}\OperatorTok{$}\KeywordTok{connect}\NormalTok{()}
\CommentTok{#> [1] TRUE}
\NormalTok{connection.dbFile}\OperatorTok{$}\KeywordTok{isConnected}\NormalTok{()}
\CommentTok{#> [1] TRUE}
\NormalTok{connection.dbFile}\OperatorTok{$}\KeywordTok{disconnect}\NormalTok{()}
\CommentTok{#> [1] TRUE}
\NormalTok{connection.dbFile}\OperatorTok{$}\KeywordTok{isConnected}\NormalTok{()}
\CommentTok{#> [1] FALSE}
\end{Highlighting}
\end{Shaded}

Die SqlConnection Klasse verwendet in seinem Nucleus das R Paket DBI. Im
Gegensatz zu diesem erzeugt der Builder aber per default eine
geschlossene Verbindung. Diese kann explizit per \texttt{connect()}
geöffnet oder \texttt{disconnect()} geschlossen werden. Weitere Details
zum Verhalten der Connection Klasse werden im nächsten Abschnitt näher
erläutert. Die Methoden zum steuern der der Verbindung geben jeweils
einen boolean Wert als Indikator zurück.

\hypertarget{abfragen}{%
\subsection{Abfragen}\label{abfragen}}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{query<-connection.dbFile}\OperatorTok{$}\KeywordTok{createQuery}\NormalTok{(}\DataTypeTok{sql =} \StringTok{"SELECT * FROM diamonds"}\NormalTok{)}
\CommentTok{#> <Validator> for parent class: <SqlCommand> created}
\CommentTok{#> <SqlCommand> :: <SELECT * FROM diamonds>}
\CommentTok{#> for provider: <dbFile> created}

\KeywordTok{class}\NormalTok{(query)}
\CommentTok{#> [1] "SqlCommand"          "Abstrakt SqlCommand" "R6"}

\NormalTok{query}\OperatorTok{$}\NormalTok{provider}
\CommentTok{#> [1] "dbFile"}

\NormalTok{query}\OperatorTok{$}\NormalTok{sql}
\CommentTok{#> [1] "SELECT * FROM diamonds"}

\CommentTok{#query$sql<-"SELECT * FROM diamonds"}
\CommentTok{#Fehler in query$sql <- "SELECT * FROM emeralds" : }
\CommentTok{#kann den Wert einer festgestellten Bindung für 'sql' nicht ändern}
\end{Highlighting}
\end{Shaded}

Mit \texttt{createQuery()} instanziiert die \texttt{SqlConnection} ein
SqlCommand. Die Klasse dient als CRUD (Create, Read, Update, Delete)
Interface. Die aktuelle Implementierung kann SQL Statements nur als
Konkatenation verarbeiten. Um SQL-Injection (dt. SQL-Einschleusung) zu
unterbinden sowie die Flexibilität zu erhöhen, könnte in einem
zukünftigen Release parametrisierte Abfragen implementiert werden.

Im Vergleich:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{quality<-}\StringTok{"Premium"}

\CommentTok{#quality<-"Premium"}
\NormalTok{query.premium<-connection.dbFile}\OperatorTok{$}\KeywordTok{createQuery}\NormalTok{(}\DataTypeTok{sql =} \StringTok{"SELECT * FROM diamonds WHERE cut=?"}\NormalTok{)}
\CommentTok{#> <Validator> for parent class: <SqlCommand> created}
\CommentTok{#> <SqlCommand> :: <SELECT * FROM diamonds WHERE cut=?>}
\CommentTok{#> for provider: <dbFile> created}
\CommentTok{#qquery.premium$addParameter(name="quality", value= quality)}
\NormalTok{query.premium}\OperatorTok{$}\NormalTok{sql}
\CommentTok{#> [1] "SELECT * FROM diamonds WHERE cut=?"}

\NormalTok{query.premium<-connection.dbFile}\OperatorTok{$}\KeywordTok{createQuery}\NormalTok{(}\DataTypeTok{sql =} \KeywordTok{paste}\NormalTok{(}\StringTok{"SELECT * FROM diamonds WHERE cut='"}\NormalTok{,quality,}\StringTok{"'"}\NormalTok{,}\DataTypeTok{sep=}\StringTok{""}\NormalTok{))}
\CommentTok{#> <Validator> for parent class: <SqlCommand> created}
\CommentTok{#> <SqlCommand> :: <SELECT * FROM diamonds WHERE cut='Premium'>}
\CommentTok{#> for provider: <dbFile> created}
\NormalTok{query.premium}\OperatorTok{$}\NormalTok{sql}
\CommentTok{#> [1] "SELECT * FROM diamonds WHERE cut='Premium'"}
\end{Highlighting}
\end{Shaded}

Mit \texttt{createQuery()} instanziiert die \texttt{SqlConnection} ein
SqlCommand. Die Klasse dient als CRUD (Create, Read, Update, Delete)
Interface. Die aktuelle Implementierung kann SQL Statements nur als
Konkatenation verarbeiten. Um SQL-Injection (dt. SQL-Einschleusung) zu
unterbinden sowie die Flexibilität zu erhöhen, könnte in einem
zukünftigen Release parametrisierte Abfragen implementiert werden.
Darauf aufbauend kann das SqlCommand dann um die Möglichkeit des
Prepared Statements erweitert werden. Ein Prepared Statement ist eine
sogenannte vorbereitete Anweisung für ein Datenbanksystem. Im Gegensatz
zu gewöhnlichen Statements enthält es noch keine Parameterwerte.
Stattdessen werden dem Datenbanksystem Platzhalter übergeben. Soll ein
Statement mit unterschiedlichen Parametern mehrere Male (z. B. innerhalb
einer Schleife) auf dem Datenbanksystem ausgeführt werden, können
Prepared Statements einen Geschwindigkeitsvorteil bringen, da das
Statement schon vorübersetzt im Datenbanksystem vorliegt und nur noch
mit den neuen Parametern ausgeführt werden muss.

\hypertarget{ergebniss-einer-abfrage}{%
\subsection{Ergebniss einer Abfrage}\label{ergebniss-einer-abfrage}}

Mit \texttt{fetch()} wird die Query ausgeführt und die
\texttt{SqlConnection} liefert über das \texttt{SqlCommand} Interface
ein Objekt der Klasse \texttt{SqlResult} zurück. Handelt es sich bei der
Abfrage um eine SQL-Aktionsabfrage, bspw.ein ``INSERT'' oder ``DELETE''
wird die Query mit dem Befehl \texttt{execute()} ausgeführt und als
Ergebnis wird die Anzahl der vom SQL-Statement betroffenen Datensätze
zurück geliefert.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{result<-query}\OperatorTok{$}\KeywordTok{fetch}\NormalTok{()}
\CommentTok{#> <Validator> for parent class: <SqlResult> created}
\CommentTok{#> <SqlCommand> :: <SELECT * FROM diamonds>}
\CommentTok{#> for provider: <dbFile> ausgeführt}

\NormalTok{result}\OperatorTok{$}\KeywordTok{rows}\NormalTok{()}
\CommentTok{#> [1] 53940}

\KeywordTok{class}\NormalTok{(result)}
\CommentTok{#> [1] "SqlResult" "R6"}
\end{Highlighting}
\end{Shaded}

Mit \texttt{data} kann direkt auf die Daten zugegriffen werden:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{#(Achtung Feld Zugriff)}
\KeywordTok{head}\NormalTok{(result}\OperatorTok{$}\NormalTok{data)}
\CommentTok{#>   carat       cut color clarity depth table price    x    y    z}
\CommentTok{#> 1  0.23     Ideal     E     SI2  61.5    55   326 3.95 3.98 2.43}
\CommentTok{#> 2  0.21   Premium     E     SI1  59.8    61   326 3.89 3.84 2.31}
\CommentTok{#> 3  0.23      Good     E     VS1  56.9    65   327 4.05 4.07 2.31}
\CommentTok{#> 4  0.29   Premium     I     VS2  62.4    58   334 4.20 4.23 2.63}
\CommentTok{#> 5  0.31      Good     J     SI2  63.3    58   335 4.34 4.35 2.75}
\CommentTok{#> 6  0.24 Very Good     J    VVS2  62.8    57   336 3.94 3.96 2.48}

\CommentTok{#result$data<-NULL}
\CommentTok{#Fehler in result$data <- NULL : }
\CommentTok{#kann den Wert einer festgestellten Bindung für 'data' nicht ändern}
\end{Highlighting}
\end{Shaded}

\hypertarget{verhalten-der-verbindung-bei-einer-abfrage}{%
\subsection{Verhalten der Verbindung bei einer
Abfrage}\label{verhalten-der-verbindung-bei-einer-abfrage}}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{connection.dbFile}\OperatorTok{$}\KeywordTok{isConnected}\NormalTok{()}
\CommentTok{#> [1] FALSE}

\NormalTok{result.premium<-query.premium}\OperatorTok{$}\KeywordTok{fetch}\NormalTok{(}\DataTypeTok{disconnect =} \OtherTok{TRUE}\NormalTok{)}
\CommentTok{#> <Validator> for parent class: <SqlResult> created}
\CommentTok{#> <SqlCommand> :: <SELECT * FROM diamonds WHERE cut='Premium'>}
\CommentTok{#> for provider: <dbFile> ausgeführt}

\NormalTok{connection.dbFile}\OperatorTok{$}\KeywordTok{isConnected}\NormalTok{()}
\CommentTok{#> [1] FALSE}

\KeywordTok{head}\NormalTok{(result.premium}\OperatorTok{$}\NormalTok{data)}
\CommentTok{#>   carat     cut color clarity depth table price    x    y    z}
\CommentTok{#> 1  0.21 Premium     E     SI1  59.8    61   326 3.89 3.84 2.31}
\CommentTok{#> 2  0.29 Premium     I     VS2  62.4    58   334 4.20 4.23 2.63}
\CommentTok{#> 3  0.22 Premium     F     SI1  60.4    61   342 3.88 3.84 2.33}
\CommentTok{#> 4  0.20 Premium     E     SI2  60.2    62   345 3.79 3.75 2.27}
\CommentTok{#> 5  0.32 Premium     E      I1  60.9    58   345 4.38 4.42 2.68}
\CommentTok{#> 6  0.24 Premium     I     VS1  62.5    57   355 3.97 3.94 2.47}
\end{Highlighting}
\end{Shaded}

Die Verbindung wird nur für einen Task geöffnet und anschließend sofort
wieder geschlossen. Der optionale Steuerungsparameter
\texttt{disconnect} ist per default auf TRUE gesetzt.

\hypertarget{testlauf}{%
\subsection{Testlauf}\label{testlauf}}

Objektorientierte Programmiersprachen (OOP) kapseln Daten und Verhalten
in Objekten, hingegen legen relationale Datenbanken Daten in Tabellen
ab. Die beiden Paradigmen sind grundlegend verschieden. So kapseln
Objekte ihren Zustand und ihr Verhalten hinter einer Schnittstelle und
haben eine eindeutige Identität.

Für den Testlauf wird der diamonds Datensatz verwendet und beispielhaft
eine einfache (fiktive) Geschäftslogik bestehend aus einer Tabelle sowie
nur lesenden Aufgaben angenommen.

Im Testlauf soll exemplarisch dargestellt werden, welche Möglichkeiten R
im Bereich der Objektorientierten Programmierung bietet und wie eine
größere Datenbank Anwendung strukturiert nach den Grundsätzen der
Objektorientierung implementiert werden könnte.

\hypertarget{geschuxe4ftslogik}{%
\subsection{Geschäftslogik}\label{geschuxe4ftslogik}}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{business<-}\KeywordTok{diamondsFactory}\NormalTok{(connection.dbFile)}
\CommentTok{#> <Validator> for parent class: <Diamonds interface> created}
\CommentTok{#> <Validator> for parent class: <Diamonds interface> created}
\CommentTok{#> <Validator> for parent class: <HashMap> created}
\CommentTok{#> <Validator> for parent class: <HashMap> created}

\KeywordTok{class}\NormalTok{(business)}
\CommentTok{#> [1] "Diamonds interface"     "Abstrakt businessLogic"}
\CommentTok{#> [3] "R6"}

\NormalTok{diamonds.best<-business}\OperatorTok{$}\KeywordTok{loadBestQuality}\NormalTok{()}
\CommentTok{#> <Validator> for parent class: <SqlCommand> created}
\CommentTok{#> <SqlCommand> :: <SELECT * FROM diamonds WHERE cut = 'Very Good'>}
\CommentTok{#> for provider: <dbFile> created }
\CommentTok{#> <Validator> for parent class: <SqlResult> created}
\CommentTok{#> <SqlCommand> :: <SELECT * FROM diamonds WHERE cut = 'Very Good'>}
\CommentTok{#> for provider: <dbFile> ausgeführt}

\KeywordTok{head}\NormalTok{(diamonds.best}\OperatorTok{$}\NormalTok{data)}
\CommentTok{#>   carat       cut color clarity depth table price    x    y    z}
\CommentTok{#> 1  0.24 Very Good     J    VVS2  62.8    57   336 3.94 3.96 2.48}
\CommentTok{#> 2  0.24 Very Good     I    VVS1  62.3    57   336 3.95 3.98 2.47}
\CommentTok{#> 3  0.26 Very Good     H     SI1  61.9    55   337 4.07 4.11 2.53}
\CommentTok{#> 4  0.23 Very Good     H     VS1  59.4    61   338 4.00 4.05 2.39}
\CommentTok{#> 5  0.30 Very Good     J     SI1  62.7    59   351 4.21 4.27 2.66}
\CommentTok{#> 6  0.23 Very Good     E     VS2  63.8    55   352 3.85 3.92 2.48}

\NormalTok{diamonds.selected<-business}\OperatorTok{$}\KeywordTok{loadColumns}\NormalTok{(}\StringTok{"carat"}\NormalTok{,}\StringTok{"color"}\NormalTok{)}
\CommentTok{#> <Validator> for parent class: <SqlCommand> created}
\CommentTok{#> <SqlCommand> :: <SELECT carat FROM diamonds>}
\CommentTok{#> for provider: <dbFile> created }
\CommentTok{#> <Validator> for parent class: <SqlResult> created}
\CommentTok{#> <SqlCommand> :: <SELECT carat FROM diamonds>}
\CommentTok{#> for provider: <dbFile> ausgeführt}

\KeywordTok{head}\NormalTok{(diamonds.selected}\OperatorTok{$}\NormalTok{data)}
\CommentTok{#>   carat}
\CommentTok{#> 1  0.23}
\CommentTok{#> 2  0.21}
\CommentTok{#> 3  0.23}
\CommentTok{#> 4  0.29}
\CommentTok{#> 5  0.31}
\CommentTok{#> 6  0.24}
\end{Highlighting}
\end{Shaded}

Innerhalb der Businesslogik werden die relationen Zusammenhänge der
zugrundeligenden Datenbank implementiert. Die Businesslogik kann um
komplexe SQL-Abfragen über meherere Tabellen sowie weiterverarbeitende,
Clientseitige Dunkelverabreitung erweitert werden. Beispiel: Kreditdaten
kommen aus der Datenbank in der Businesslogik an, fließen in der
Businesslogik in ein Prognosemodell und werden dann erst ans Frontend
geliefert.

\hypertarget{errorhandling}{%
\subsection{Errorhandling}\label{errorhandling}}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{diamonds.lowbudget<-business}\OperatorTok{$}\KeywordTok{loadQuality}\NormalTok{(}\StringTok{"Poor"}\NormalTok{,}\StringTok{"Fair"}\NormalTok{, }\StringTok{"Good"}\NormalTok{)}
\CommentTok{#> Warning: <Diamonds interface>}
\CommentTok{#> Proc: <loadQuality()>}
\CommentTok{#> Beschreibung: <Nur folgende Qualitäten können abgefragt werden: Fair;Good;Ideal;Premium;Very Good>}

\NormalTok{diamonds.lowbudget<-business}\OperatorTok{$}\KeywordTok{loadQuality}\NormalTok{(}\StringTok{"Fair"}\NormalTok{, }\StringTok{"Good"}\NormalTok{)}
\CommentTok{#> <Validator> for parent class: <SqlCommand> created}
\CommentTok{#> <SqlCommand> :: <SELECT * FROM diamonds WHERE cut IN ("Fair")>}
\CommentTok{#> for provider: <dbFile> created }
\CommentTok{#> <Validator> for parent class: <SqlResult> created}
\CommentTok{#> <SqlCommand> :: <SELECT * FROM diamonds WHERE cut IN ("Fair")>}
\CommentTok{#> for provider: <dbFile> ausgeführt}

\KeywordTok{head}\NormalTok{(diamonds.lowbudget}\OperatorTok{$}\NormalTok{data)}
\CommentTok{#>   carat  cut color clarity depth table price    x    y    z}
\CommentTok{#> 1  0.22 Fair     E     VS2  65.1    61   337 3.87 3.78 2.49}
\CommentTok{#> 2  0.86 Fair     E     SI2  55.1    69  2757 6.45 6.33 3.52}
\CommentTok{#> 3  0.96 Fair     F     SI2  66.3    62  2759 6.27 5.95 4.07}
\CommentTok{#> 4  0.70 Fair     F     VS2  64.5    57  2762 5.57 5.53 3.58}
\CommentTok{#> 5  0.70 Fair     F     VS2  65.3    55  2762 5.63 5.58 3.66}
\CommentTok{#> 6  0.91 Fair     H     SI2  64.4    57  2763 6.11 6.09 3.93}
\end{Highlighting}
\end{Shaded}

Das Errorhandling wird ebenfalls in der Businesslogik abgebildet.

\hypertarget{objektrelationale-abbildung}{%
\subsection{Objektrelationale
Abbildung}\label{objektrelationale-abbildung}}

Des Weiteren kann mit Hilfe von Objekt-orientierter Programmierung und
dem \texttt{rdao} framework eine Objektrelationale Abbildung dagestellt
werden. Eine Objektrelationale Abbildung (englisch object-relational
mapping, ORM) ist eine Technik der Softwareentwicklung, mit der ein in
einer objektorientierten Programmiersprache geschriebenes
Anwendungsprogramm seine Objekte in einer relationalen Datenbank ablegen
kann. Dem Programm erscheint die Datenbank dann als objektorientierte
Datenbank, was die Programmierung erleichtert.

Im einfachsten Fall werden Klassen auf Tabellen abgebildet, jedes Objekt
entspricht einer Tabellenzeile und für jedes Attribut wird eine
Tabellenspalte reserviert. Die Identität eines Objekts entspricht dem
Primärschlüssel der Tabelle:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{diamonds<-business}\OperatorTok{$}\KeywordTok{loadDiamonds}\NormalTok{()}
\CommentTok{#> <Validator> for parent class: <SqlCommand> created}
\CommentTok{#> <SqlCommand> :: <SELECT * FROM diamonds>}
\CommentTok{#> for provider: <dbFile> created }
\CommentTok{#> <Validator> for parent class: <SqlResult> created}
\CommentTok{#> <SqlCommand> :: <SELECT * FROM diamonds>}
\CommentTok{#> for provider: <dbFile> ausgeführt}

\KeywordTok{class}\NormalTok{(diamonds)}
\CommentTok{#> [1] "list"}

\KeywordTok{class}\NormalTok{(diamonds[[}\DecValTok{1}\NormalTok{]])}
\CommentTok{#> [1] "Diamond" "R6"}
\end{Highlighting}
\end{Shaded}

\hypertarget{fazit}{%
\subsubsection{Fazit}\label{fazit}}

Mit dem DBI- und dem R6 Paket existieren in R mächtige Werkzeuge zum
entwickeln von Objektorientierten Datenbanklösungen.

Die Anwendung kann als Blaupause für weitere Implementierungen dienen
und vermittelt einen ersten Eindruck wie eine Objektorientierte
Programmstruktur in R aussehen könnte.

Aufgrund der Komplexität des Themas und der im Rahmen einer
Projektarbeit bemessenen Zeit verbleiben viele offene Fragen:

Wie könnten tatsächliche Interface implementiert werden? Wie schreibt
die Anwendung das gemappte Objekt (effizient) zurück in die Datenbank?
Wie könnte das SqlResult noch weiter gekapselt werden?


\end{document}
