"x",
"y",
"z"
),
.cuts = c("Fair", "Good", "Very Good", "Premium", "Ideal"),
.colors = c("E", "I", "J", "H", "F"),
.columnMap = NULL,
.cutMap = NULL,
.colorMap = NULL,
availableQuality = function() {
return(c("Fair", "Good", "Very Good", "Premium", "Ideal"))
}
),
public = list(
initialize = function(connection) {
private$.validator <- Validator$new(self)
if (private$.validator$isTrustedConnection(connection)) {
private$.connection <- connection
} else {
private$.validator$throwError("Connection ist ungültig", "initialize()")
}
private$.columnMap = HashMap$new()
private$.cutMap = HashMap$new()
private$.columnMap$put(private$.columns, private$.columns)
print(private$.columnMap$contains("carat"))
print(private$.columnMap$contains("sdsd"))
print(private$.columnMap$getKeys())
},
loadAll = function() {
sql <- "SELECT * FROMdiamonds"
return(private$.connection$createQuery(sql = sql)$fetch())
},
loadSelectedQuality = function(q) {
sql.raw <- "SELECT * FROM diamonds WHERE cut IN (%s)"
sql <- sprintf(sql.raw, paste0("\"", q, "\"", collapse = ","))
return(private$.connection$createQuery(sql = sql)$fetch())
},
loadPremiumQuality = function() {
sql <- "SELECT * FROM diamonds"
return(private$.connection$createQuery(sql = sql)$fetch())
},
loadColumns = function(columns = c("carat",
"cut",
"color",
"clarity",
"depth",
"table",
"price",
"x",
"y",
"z")) {
if (!private$.columnMap$contains(columns)){
private$.validator$throwError(paste("Nur folgende Spalten können abgefragt werden:",paste(private$.columnMap$getKeys(),sep=";"),"loadColumns()")
}
sql <- paste("SELECT" , paste(columns,sep=",", "FROM diamonds"))
return(private$.connection$createQuery(sql = sql)$fetch())
}
)
)
IDiamonds <- R6::R6Class(
classname = "Diamonds interface",
inherit = businessLogic,
portable = TRUE,
private = list(.validator = NULL,
.diamonds = NULL),
public = list(
initialize = function(connection) {
private$.validator <- Validator$new(self)
super$initialize(connection)
}
)
)
businessLogic <- R6::R6Class(
classname = "businessLogic",
inherit = NULL,
portable = TRUE,
private = list(
.validator = NULL,
.connection = NULL,
.columns = c(
"carat",
"cut",
"color",
"clarity",
"depth",
"table",
"price",
"x",
"y",
"z"
),
.cuts = c("Fair", "Good", "Very Good", "Premium", "Ideal"),
.colors = c("E", "I", "J", "H", "F"),
.columnMap = NULL,
.cutMap = NULL,
.colorMap = NULL,
availableQuality = function() {
return(c("Fair", "Good", "Very Good", "Premium", "Ideal"))
}
),
public = list(
initialize = function(connection) {
private$.validator <- Validator$new(self)
if (private$.validator$isTrustedConnection(connection)) {
private$.connection <- connection
} else {
private$.validator$throwError("Connection ist ungültig", "initialize()")
}
private$.columnMap = HashMap$new()
private$.cutMap = HashMap$new()
private$.columnMap$put(private$.columns, private$.columns)
print(private$.columnMap$contains("carat"))
print(private$.columnMap$contains("sdsd"))
print(private$.columnMap$getKeys())
},
loadAll = function() {
sql <- "SELECT * FROMdiamonds"
return(private$.connection$createQuery(sql = sql)$fetch())
},
loadSelectedQuality = function(q) {
sql.raw <- "SELECT * FROM diamonds WHERE cut IN (%s)"
sql <- sprintf(sql.raw, paste0("\"", q, "\"", collapse = ","))
return(private$.connection$createQuery(sql = sql)$fetch())
},
loadPremiumQuality = function() {
sql <- "SELECT * FROM diamonds"
return(private$.connection$createQuery(sql = sql)$fetch())
},
loadColumns = function(columns = c("carat",
"cut",
"color",
"clarity",
"depth",
"table",
"price",
"x",
"y",
"z")) {
if (!private$.columnMap$contains(columns)){
private$.validator$throwError(paste("Nur folgende Spalten können abgefragt werden:",paste(private$.columnMap$getKeys(),sep=";"),"loadColumns()"))
}
sql <- paste("SELECT" , paste(columns,sep=",", "FROM diamonds"))
return(private$.connection$createQuery(sql = sql)$fetch())
}
)
)
IDiamonds <- R6::R6Class(
classname = "Diamonds interface",
inherit = businessLogic,
portable = TRUE,
private = list(.validator = NULL,
.diamonds = NULL),
public = list(
initialize = function(connection) {
private$.validator <- Validator$new(self)
super$initialize(connection)
}
)
)
diamondsFactory = function(connection) {
return(IDiamonds$new(connection))
}
cnn <-
factory()$dbFile("/Users/cnitz/Dev/R/rdao/db files external/Diamonds.db")$build()
diamond <- diamondsFactory(connection = cnn)
d <- diamond$loadAll()
cnn <-
factory()$dbFile("/Users/cnitz/Dev/R/rdao/db files external/Diamonds.db")$build()
diamond <- diamondsFactory(connection = cnn)
d <- diamond$loadAll()
d$data
d <- diamond$loadColumns(columns = c("cut","color"))
hm<-HashMap$new()
hm$put(c("Fair", "Good", "Very Good", "Premium", "Ideal"))
hm$getKeys()
hm$contains(c("Fair", "Good", "Very Good", "Premium", "Ideal"))
#' Class providing some methods to store data into a hashtable and access stored items via key
#'
#'R lists with named elements are not hashed.
#'Hash lookups are O(1), because during insert the key is converted to an integer using a hash function,
#'and then the value put in the space hash(key) % num_spots of an array num_spots long
#'(this is a big simplification and avoids the complexity of dealing with collisions).
#'Lookups of the key just require hashing the key to find the value's position
#'(which is O(1), versus a O(n) array lookup).
#'R lists use name lookups which are O(n).
#'
#' @docType class
#' @importFrom R6 R6Class
#' @keywords mapping
#'
#' @section Construction:
#' ```
#' HashMap$new()
#' ```
#' @return Object of \code{\link{R6Class}} with methods for key-value mapping
#' @format \code{\link{R6Class}} object.
#' @examples
#' hm<-HashMap$new()
#' keys<- c("tic", "tac", "toe")
#' values <- c(1, 22, 333)
#'
#' hm$put("key",1)
#' hm$put(key = keys,value = values)
#' hm$get(keys)
#' hm$get("tic")
#' hm$size()
#' hm
#' hm$remove("tic")
#' hm$get("tic")
#' hm$size()
#' hm$getKeys()[1]
#' hm$getValues()
#'
#' @field field(s) access all via ()
#' @section Methods:
#' \describe{
#'   \item{Documentation}{For full documentation of each method go to https://github.com/ChrisNice89/ORM}
#'   \item{\code{new()}}{This method creates a HashMap \code{instance}.}
#'   \item{\code{put(key = "", value = NA)}}{store key-value pair(s)}
#'   \item{\code{get(key,unname=TRUE)}}{access item(s) with associated key(s)}}
#' @family utils
#' @export
HashMap <- R6::R6Class(
classname = "HashMap",
inherit = NULL,
portable = TRUE,
public = list(
#constructor
initialize = function(name = "Default Dictionary", capacity = 100L) {
private$.validator <- Validator$new(self)
private$.name <- name
private$.hash <- new.env(hash = TRUE,
parent = emptyenv(),
size = capacity)
private$.hash.put <-
Vectorize(assign, vectorize.args = c("x", "value"))
private$.hash.get <- Vectorize(get, vectorize.args = "x")
private$.hash.contains <-
Vectorize(exists, vectorize.args = "x")
invisible(self)
},
put = function(key = "", value = NA) {
##private$.validator.isString(key)
#private$.hash[[key]] <- value
private$.hash.put(key, value, private$.hash)
invisible(self)
},
get = function(key, unname = TRUE) {
if (unname) {
return(setNames(private$.hash.get(key,  private$.hash), NULL))
} else{
return(private$.hash.get(key,  private$.hash))
}
},
contains = function(key) {
return(all(as.vector(private$.hash.contains(key, private$.hash)))
},
remove = function(key) {
rm(list = key, envir = private$.hash)
invisible(self)
},
getKeys = function() {
return(ls(private$.hash))
},
getValues = function() {
return(setNames(private$.hash.get(ls(hash), private$.hash)), NULL)
},
size = function() {
return(length(private$.hash))
},
print = function(...) {
cat("<",
class(self)[1],
"> with name: <",
private$.name,
"> created",
"\n",
sep = "")
cat("", "<key-value-pairs> ", "\n", sep = "\t")
if (self$size() > 0) {
x <- self$getKeys()
e <- private$.hash
for (i in 1:length(x)) {
if (x[i] %in% ls(envir = e)) {
cat(paste("    ", x[i] , " :: ", get(ls(envir = e)[which(ls(envir = e) %in% x[i])], envir = e)), sep =
"\n")
}
}
} else {
cat("", "<Empty> ", "\n", sep = "\t")
}
}
),
# active = list(
#   getKeys =function(){
#     return(ls(private$.hash))
#   },
#
#   size=function(){
#     return(length(private$.hash))
#   }
# ),
private = list(
.name = "Default Dictionary",
.hash = NULL,
.hash.get = NULL,
.hash.put = NULL,
.hash.contains = NULL,
.validator = NULL
)
)
# foo <- c(1, 1)
# isDefined <- Vectorize(mode, vectorize.args = "x")
# isDefined(foo)
# all(isDefined(foo)) %in% c("logical", "numeric", "complex", "character")
#
# mode(foo) %in% c("logical", "numeric", "complex", "character")
#
# hm <- HashMap$new()
# validate <- Validator$new(hm)
# is(validate, "R6")
# class(validate)[2]
#
# validate$isNumeric(c(1, 1))
# foo <- NA
# validate$isDefined(foo)
#
# foo <- 1.55555
# mode(foo)
# mode(foo) %in% c("logical", "numeric", "complex", "character")
# A <- R6::R6Class("Base",NULL)
# B <- R6::R6Class("Middle", inherit = A)
# C <- R6::R6Class("Top", inherit = B)
#
# v<- Validator$new()
# v$findClasses(C)
# v$inherits(C,"Middle")
hm<-HashMap$new()
hm$put(c("Fair", "Good", "Very Good", "Premium", "Ideal"))
hm$getKeys()
hm$contains(c("Fair", "Good", "Very Good", "Premium", "Ideal"))
?all
#' Class providing some methods to store data into a hashtable and access stored items via key
#'
#'R lists with named elements are not hashed.
#'Hash lookups are O(1), because during insert the key is converted to an integer using a hash function,
#'and then the value put in the space hash(key) % num_spots of an array num_spots long
#'(this is a big simplification and avoids the complexity of dealing with collisions).
#'Lookups of the key just require hashing the key to find the value's position
#'(which is O(1), versus a O(n) array lookup).
#'R lists use name lookups which are O(n).
#'
#' @docType class
#' @importFrom R6 R6Class
#' @keywords mapping
#'
#' @section Construction:
#' ```
#' HashMap$new()
#' ```
#' @return Object of \code{\link{R6Class}} with methods for key-value mapping
#' @format \code{\link{R6Class}} object.
#' @examples
#' hm<-HashMap$new()
#' keys<- c("tic", "tac", "toe")
#' values <- c(1, 22, 333)
#'
#' hm$put("key",1)
#' hm$put(key = keys,value = values)
#' hm$get(keys)
#' hm$get("tic")
#' hm$size()
#' hm
#' hm$remove("tic")
#' hm$get("tic")
#' hm$size()
#' hm$getKeys()[1]
#' hm$getValues()
#'
#' @field field(s) access all via ()
#' @section Methods:
#' \describe{
#'   \item{Documentation}{For full documentation of each method go to https://github.com/ChrisNice89/ORM}
#'   \item{\code{new()}}{This method creates a HashMap \code{instance}.}
#'   \item{\code{put(key = "", value = NA)}}{store key-value pair(s)}
#'   \item{\code{get(key,unname=TRUE)}}{access item(s) with associated key(s)}}
#' @family utils
#' @export
HashMap <- R6::R6Class(
classname = "HashMap",
inherit = NULL,
portable = TRUE,
public = list(
#constructor
initialize = function(name = "Default Dictionary", capacity = 100L) {
private$.validator <- Validator$new(self)
private$.name <- name
private$.hash <- new.env(hash = TRUE,
parent = emptyenv(),
size = capacity)
private$.hash.put <-
Vectorize(assign, vectorize.args = c("x", "value"))
private$.hash.get <- Vectorize(get, vectorize.args = "x")
private$.hash.contains <-
Vectorize(exists, vectorize.args = "x")
invisible(self)
},
put = function(key = "", value = NA) {
##private$.validator.isString(key)
#private$.hash[[key]] <- value
private$.hash.put(key, value, private$.hash)
invisible(self)
},
get = function(key, unname = TRUE) {
if (unname) {
return(setNames(private$.hash.get(key,  private$.hash), NULL))
} else{
return(private$.hash.get(key,  private$.hash))
}
},
contains = function(key) {
return(all(as.vector(private$.hash.contains(key, private$.hash)))
},
remove = function(key) {
rm(list = key, envir = private$.hash)
invisible(self)
},
getKeys = function() {
return(ls(private$.hash))
},
getValues = function() {
return(setNames(private$.hash.get(ls(hash), private$.hash)), NULL)
},
size = function() {
return(length(private$.hash))
},
print = function(...) {
cat("<",
class(self)[1],
"> with name: <",
private$.name,
"> created",
"\n",
sep = "")
cat("", "<key-value-pairs> ", "\n", sep = "\t")
if (self$size() > 0) {
x <- self$getKeys()
e <- private$.hash
for (i in 1:length(x)) {
if (x[i] %in% ls(envir = e)) {
cat(paste("    ", x[i] , " :: ", get(ls(envir = e)[which(ls(envir = e) %in% x[i])], envir = e)), sep =
"\n")
}
}
} else {
cat("", "<Empty> ", "\n", sep = "\t")
}
}
),
# active = list(
#   getKeys =function(){
#     return(ls(private$.hash))
#   },
#
#   size=function(){
#     return(length(private$.hash))
#   }
# ),
private = list(
.name = "Default Dictionary",
.hash = NULL,
.hash.get = NULL,
.hash.put = NULL,
.hash.contains = NULL,
.validator = NULL
)
)
# foo <- c(1, 1)
# isDefined <- Vectorize(mode, vectorize.args = "x")
# isDefined(foo)
# all(isDefined(foo)) %in% c("logical", "numeric", "complex", "character")
#
# mode(foo) %in% c("logical", "numeric", "complex", "character")
#
# hm <- HashMap$new()
# validate <- Validator$new(hm)
# is(validate, "R6")
# class(validate)[2]
#
# validate$isNumeric(c(1, 1))
# foo <- NA
# validate$isDefined(foo)
#
# foo <- 1.55555
# mode(foo)
# mode(foo) %in% c("logical", "numeric", "complex", "character")
# A <- R6::R6Class("Base",NULL)
# B <- R6::R6Class("Middle", inherit = A)
# C <- R6::R6Class("Top", inherit = B)
#
# v<- Validator$new()
# v$findClasses(C)
# v$inherits(C,"Middle")
hm<-HashMap$new()
hm$put(c("Fair", "Good", "Very Good", "Premium", "Ideal"))
hm$getKeys()
hm$contains(c("Fair", "Good", "Very Good", "Premium", "Ideal"))
hm<-HashMap$new()
hm$put(c("Fair", "Good", "Very Good", "Premium", "Ideal"))
hm$getKeys()
hm$contains(c("Fair", "Good", "Very Good", "Premium", "Ideal"))
all(hm$contains(c("Fair", "Good", "Very Good", "Premium", "Ideal")))
